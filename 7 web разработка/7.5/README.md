# Docker

## Container & Image

**Container** (контейнер) — процесс, который выполняется на хосте. Хост может быть локальным или удаленным. Когда оператор выполняет запуск, докер контейнер изолирован, поскольку у него есть собственная файловая система, собственная сеть и собственное изолированное дерево процессов, отдельное от хоста.   
Запуск контейнера:  

```docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...]  ```
* 
**Image** (образ) — основа для контейнера. Создается из файла конфигурации
(Dockerfile) и контекста. Контекстом являются локальные файлы или другие образы.
Каждый новый образ может наслаиваться для очередной версии, по аналогии с git
иерархией. Сборка образа:  
```docker image build [OPTIONS] PATH | URL | -```

## Тома Volumes

**Volumes** (тома) — выделенный объем памяти для использования в контейнерах.  
Тома позволяют:  
* объединять один том между разными контейнерами
* архивировать и шифровать содержимое
* подключать внешние источники из облака или внешних носителей
* использовать многократно  
  
Создание тома и монтирование в контейнере:  
```docker volume create my-vol```  
```docker run -d --name devtest --mount source=myvol2,target=/app nginx:latest```
- docker volume create - создание
- docker volume inspect - отобразить подробную информацию
- docker volume ls список томов
- docker volume prune - удалить все неиспользуемые локальные тома
- docker volume rm - удаление томов  

По умолчанию любые данные, созданные внутри контейнера, доступны только внутри контейнера и только во время его работы.  
Тома можно использовать для обмена файлами между хост-системой и контейнером Docker.  
Предположим, вы хотите использовать официальный образ Docker Nginx и сохранить постоянную копию файлов журнала Nginx для последующего анализа. Тогда после $ docker run мы напишем:  
```--name=nginx -d -v ~/nginxlogs:/var/log/nginx -p 5000:80 nginx```  
где ```--name=nginx``` - имя контейнера, ```-d``` - запуск в фоновом режиме, ```-v ~/nginxlogs:/var/log/nginx``` - монтирование тома bindmount, ```-p 5000:80``` - переадресация портов с 5000 порта хост-машины на 80 порт службы внутри контейнера, ```nginx``` - название запускаемого контейнера

## Networks, сетевой драйвер

Контейнеры можно объединять в сеть и запускать в разных режимах сети в зависимости от выбранного драйвера:
* bridge — сетевой драйвер по умолчанию. Каждый контейнер работает изолированно, при необходимости маршруты настраиваются вручную.
* host — для автономных контейнеров, убирается изоляция и сеть с хост-машиной общая.
* overlay — соединяют несколько демонов Docker вместе и позволяют службам роя взаимодействовать друг с другом. Эта стратегия устраняет необходимость выполнять маршрутизацию на уровне ОС между контейнерами.
* macvlan — позволяют назначать MAC-адрес контейнеру, чтобы он отображался как физическое устройство в вашей сети.
* none — для этого контейнера отключаются все сети.
* user-plugins — можно

Объединение двух контейнеров в сеть:  

* docker network create --driver=bridge test-net - создать сеть при помощи драйвера bridge
* docker run -dit --name alpine1 --network test-net alpine
* docker run -it --name alpine2 --network test-net alpine

## Сборка

Сборка контейнера из файла Dockerfile в текущем каталоге и пометить образ
указанным тегом
```
$ docker build --help
Usage: docker build [OPTIONS] PATH | URL | -

$ docker build --tag my-server:1.0 .
```
## Запуск
```
$ docker run --help
Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]

$ docker run --publish 8000:8000 --detach --name my-name my-server:1.0
```
где:
* --publish или -p просит Docker перенаправить трафик на хост с 8000 на 8080 порт.
Контейнеры по умолчанию изолированы в своей сети, чтобы сетевой трафик был
доступен извне, его необходимо перенаправить по указанному порту.
* --detach или -d запуск Docker в фоновом режиме, чтобы освободить консоль.
* --name или -n специальное имя, по которому можно в дальнейшем ссылаться на
контейнер. По умолчанию выдается случайное.

## Конфигурация Dockerfile
```
# Использовать официальный образ родительского образа / слепка.
FROM python:3.8
# Установка рабочей директории, откуда выполняются команды внутри
контейнера.
WORKDIR /code
# Скопировать все файлы с локальной машины внутрь файловой системы
виртуального образа.
COPY . .
# Запустить команду внутри образа, установка зависимостей.
RUN pip install --no-cache-dir --upgrade -r requirements.txt
# Устанавливаем виртуальное окружение
ENV MY_ENV=env
# Добавить мета-информацию к образу для открытия порта к прослушиванию.
EXPOSE 6060
# Выполнить команду внутри контейнера
CMD ["python3", "-u", "main.py", "--host", "0.0.0.0", "--port", "6060"] # старый варинат gunicorn my_proj.wsgi -b 0.0.0.0:8000
```
## Основные команды
* **FROM** (+FROM as) — контекст из базового образа
* **ADD** и **COPY** — копирование файлов из хоста в контейнер
* **RUN** — запуск команды внутри образа
* **CMD** — запуск команды с разделением аргументов внутри массива
* **ENTRYPOINT** — запуск команды в контейнере через run
* **VOLUME** — настройка томов
* **ARG** — задает переменные, которые пользователь передает сборщику образа docker build с помощью флага --build-arg <varname>=<value>
* **ENV** — замена переменных окружения для контейнера
* **WORKDIR** — устанавливает рабочий каталог для всех инструкций RUN, CMD, ENTRYPOINT, COPY и ADD, которые будут выполнены в Dockerfile.

## Pull (загрузка контейнера из реестра)
Шаблон команды:
```
$ docker pull [OPTIONS] NAME[:TAG|@DIGEST]
```  
Запуск на примере сервера nginx https://hub.docker.com/_/nginx  
```
docker pull nginx
$ docker run --name some-nginx -d -p 8080:80 nginx
```  
В браузере доступен URL http://localhost:8080/, страница Welcome to nginx!  
Используя простой Dockerfile, можно настроить свою конфигурацию или html
```
FROM nginx:latest
COPY nginx.conf /etc/nginx/nginx.conf
COPY static-html-directory /usr/share/nginx/html
```
```
$ docker build -t my-nginx ./Dockerfile
$ docker run --name my-nginx-server -d -p 8081:80 my-nginx
```

## Push (загрузка контейнера в реестр)
Шаблон команды:  
```
$ docker push [OPTIONS] NAME[:TAG]
```
Пометим текущий образ нужным тэгом для удобства и проверим его в списке:  
```
$ docker tag my-nginx my-nginx:develop
$ docker images
REPOSITORY TAG IMAGE ID CREATED SIZE
my-nginx develop b87668f7655e 13 minutes ago 133MB
my-nginx latest b87668f7655e 13 minutes ago 133MB
```
Авторизуемся и публикуем контейнер на docker-hub:  
```
$ docker login
Username: my-login
Password:
Login Succeeded
$ docker push my-nginx:develop
```
Можно загружать и запускать свой контейнер на другом хосте

## Практика

* docker --version - посмотреть версию докера
* docker run hello-world - проверка докера
* docker ps - показывает запущенные контейнеры (в виде таблицы)
* docker ps -A (или --all) - вывести все контейнеры

* docker container ls -A - то же вывести контейнеры (команда через контейнер)
* docker container - посмотреть все команды по работе с контейнером
* docker container logs id - вывести логи контейнера по его id
* docker container stop name - остановить контейнер с именем name

* docker run -it busybox - запуск контейнера бизибокс в интерактивном режиме (флаг -it), то есть сразу проваливаясь в запускаемый контейнер.
  * busybox это контейнер с полезными утилитами и инструментами для линукс. Теперь мы находимся в линуксе в контейнере бизибокс. Можно посмотреть папки командой ls -la. 
  * exit - выход из контейнера
* docker run nginx - запуск контейнера Nginx
  * nginx запустился в консоли, и теперь нет возможности писать команды, пока не выйдем через exit
* docker run -d nginx - запуск контейнера в фоновом режиме (флаг -d, консоль будет свободна, а контейнер в это время запущен). В ответ будет возвращен id контейнера
* docker run -d --name=my_nginx nginx - запуск контейнера в фоновом режиме (флаг -d) с именем (--name=) my_nginx
  * теперь можно обращаться к контейнеру по имени а не по id (имя всегда уникальное)
* docker exec -it my_nginx bash - войти в запущенный контейнер
  * curl localhost:80/ - отправили гет запрос на 80 порт и получили html приветствие nginx
  * exit - выйти из контейнера (контейнер остается запущенным)
* docker top my_nginx - посмотреть, какие процессы выполняются в контейнере my_nginx
* docker run -d -p 8888:80 --name=my_nginx2 nginx - запустили контейнер nginx под именем my_nginx2 с пробросом портов с 8888 -> 80 порт
  * curl localhost:80/ вернет ошибку
  * curl localhost:8888/ выведет приветсвенную страницу nginx
* docker run -d -p 7777:80 --name=my_nginx_volume -v c:\\Users\\mihailoff\\html:/usr/share/nginx/html nginx - запускаем контейнер nginx с подключенным томом, в котором указано два параметра: 1 - путь к папке под виндовс (слеш пришлось экранировать) и 2 - путь к папке в линукс, где запущен nginx (папка будет скопирована). Таким образом мы подменили приветсвенную страничку html nginx на свою, и при обращении ```curl localhost:7777/``` мы увидим подмененную страничку html
* docker inspect id_контейнера - просмотреть информацию о контейнере по его id в виде json

* Запустим два контейнера и соединим их через сеть
  * docker run -d --name=alpine1 alpine - запустили один контейнер алпайн
  * docker run -it --name=alpine2 alpine - запустили второй контейнер алпайн в интерактивном режиме но с свободной консолью
    * ls -la - проверяем, что мы в линуксе внутри контейнера
    * ping yandex.ru - проверяем, что есть доступ к сети
    * ping lpine1 - выдаст ошибку, так как сейчас контейнер alpine1 в одной сети, а alpine2 в другой
    * exit - выходим из контейнера
* Создам сеть и подключим к ней наши контейнеры
  * docker network create --driver=bridge test-net - создать сеть при помощи драйвера bridge
    * docker network connect test-net alpine1 - если контейнер уже создан и запущен, то подключаем его к созданной сети через команду connect. Первый параметр это сеть, второй параметр - контейнер
    * docker run -it --name=alpine2 --network test-net alpine - если контейнер не существует, то создаем его и сразу подключаем к нужной сети
    * ping lpine1 - теперь две сети видят друг друга
    * docker network -ls - можно посмотреть список доступных сетей, можно проинспектировать сеть командой ```docker inspect id_сети```
   
## Собрать образ докер
* сначала создаем в корне нашего проекта файл Dockerfile
```
# Использовать официальный образ родительского образа / слепка.
FROM python:3.9
# Установка рабочей директории, откуда выполняются команды внутри
контейнера.
WORKDIR /code
# Скопировать все файлы с локальной машины внутрь файловой системы
виртуального образа.
COPY . .
# Запустить команду внутри образа, установка зависимостей.
RUN pip install --no-cache-dir --upgrade -r requirements.txt
# Устанавливаем виртуальное окружение
ENV MY_ENV=env
# Добавить мета-информацию к образу для открытия порта к прослушиванию.
EXPOSE 6060
# Выполнить команду внутри контейнера
CMD ["python3", "-u", "main.py", "--host", "0.0.0.0", "--port", "6060"]
```
* Собираем образ нашего приложения
  * docker build . --tag=fastapi_a1 - собрать докер образ в текущей директории с тегом fastapi_a1 (с параметрами из файла Dockerfile)
  * docker images -a - вывести все образы на моем компьютере (в том числе и только что созданный)
  * docker run -d -p 6666:6060 --name=a1 fastapi_a1 - запустить созданный образ под именем a1
  * docker ps - смотрим что наш образ запущен
  * curl localhost:6666/test - выведет нашу функцию тест из пайтон приложения, если все работает
  * docker logs a1 - посмотреть логи запросов к нашему приложению

* Если мы изменили что либо в файлах проекта, нам придется заново пересобирать наш образ
  * docker build . --tag=fastapi_a2 - образ пересоберется быстрее, так как будет использован кеш от прошлого образа, и только файлы обновятся в которых были изменения
  
* Обратите внимание, что для нашего маленького приложения образ весит больше гигабайта. Что бы уменьшить размер, можно использовать обрезанную версию пайтона alpine.
* Редактируем файл Dockerfile и первой строкой ставим: ```FROM python:3.9-alpine```
  * В этом случаем при сборке образа может быть недостаточно каких либо файлов ОС (см текст ошибки). Гуглим этот текст и находим решение, нужно еще добавить второй строкой файла Dockerfile
```
FROM python:3.9-alpine 
RUN apk --no-cache gcc musl-dev linux-headers
```
  * Теперь образ весит всего лишь 240мб

* docker run -d -p 5555:6060 -e MY_ENV=env2 fastapi_a1 - запустили контейнер с переменным окружением env2 (переопределили переменное окружение из докерфайла)
* curl -X POST localhost:5555/greatings -H 'Content-Type: application/Json' -d '{"name": "Petr"} - Отправляем пост запрос с передачей параметров в нашу функцию

docker exec -it container-name sh - войти в консоль контейнера